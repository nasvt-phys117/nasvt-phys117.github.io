<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://0.0.0.0:8080/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:8080/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2025-03-17T06:08:26+00:00</updated><id>http://0.0.0.0:8080/feed.xml</id><title type="html">Nasos Voutouras</title><subtitle>This is my personal website! Welcome!</subtitle><author><name>Nasos Voutouras</name><email>nasosvt@gmail.com</email></author><entry><title type="html">Jekyll blog with docker</title><link href="http://0.0.0.0:8080/Jekyll-blog-with-docker/" rel="alternate" type="text/html" title="Jekyll blog with docker" /><published>2025-03-16T00:00:00+00:00</published><updated>2025-03-16T00:00:00+00:00</updated><id>http://0.0.0.0:8080/Jekyll%20blog%20with%20docker</id><content type="html" xml:base="http://0.0.0.0:8080/Jekyll-blog-with-docker/"><![CDATA[<h1 id="building-a-blog-with-jekyll-and-docker">Building a blog with Jekyll and Docker</h1>

<p>An easy guide and reference (mainly for myself). Probably not following best practices but it works.</p>

<p>After reading the guide we’ll have a functional blog built by Jekyll, run locally in a container using Docker.</p>

<h2 id="setting-up-the-environment">Setting up the environment</h2>

<p>I am using Ubuntu. Get the Docker cli from the store or use</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo snap install docker
</code></pre></div></div>
<p>to do it through the terminal.</p>

<p>Visual Studio Code is an excellent editor that also has terminal.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo snap install code --classic
</code></pre></div></div>
<p>We might also need <code class="language-plaintext highlighter-rouge">git</code> and <code class="language-plaintext highlighter-rouge">curl</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install git curl
</code></pre></div></div>
<p>Now, we need to create our working directory. I already have my blog created so I <code class="language-plaintext highlighter-rouge">git clone</code> it. If you don’t have that, the only thing we need is an empty directory inside of which we are going to create the <strong>Dockerfile</strong>.</p>

<p>The <strong>Dockerfile</strong> contains instructions on how the image is built, i.e. how the initial state of our container will look. We can create many containers using the same image. So, without further ado, we are going to create a  new  text file called <em>Dockerfile</em> and write the following text in it:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    FROM ruby:3.4.2-alpine3.21

    RUN apk update
    RUN apk add --no-cache build-base gcc cmake git
    
    RUN gem update bundler &amp;&amp; gem install bundler jekyll
</code></pre></div></div>
<p>This will instruct docker to create an <em>alpine</em> image (a minimal linux distribution) that includes ruby, update its packages, install some development tools and also install the <em>bundler</em> and <em>jekyll</em> gems (ruby packages).</p>

<p>Now we need to create the image:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build -t yourname/ruby .
</code></pre></div></div>
<p>This command will download the required files so it can create an image of the OS using the instructions provided inside the Dockerfile. Now we need to create a container, mount our working directory to it, expose some ports and get a bash shell so we can run commands inside the container. We will use the <code class="language-plaintext highlighter-rouge">docker run</code> command along with some flags and arguments:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -it -v /path_to_working_dir/:/home/dev/blog -w /home/dev/blog --publish 8080:8080 your_image_name  sh
</code></pre></div></div>
<p>The flags <code class="language-plaintext highlighter-rouge">-i</code>, <code class="language-plaintext highlighter-rouge">-t</code> or <code class="language-plaintext highlighter-rouge">-it</code> give us the option to have an interactive session with a terminal. The <code class="language-plaintext highlighter-rouge">-v</code> flag is used to mount a directory from the host system (for me it’s the location of the cloned repository. All my files will then be shown in the container) for which we specify the directory we need to work in and its location inside the  container. <code class="language-plaintext highlighter-rouge">-w</code> will mark the working directory so we get faster access to it. Finally, we expose some ports and also get a terminal wish sh.</p>

<p>After running this command, we can get into the container by</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker start -ai container_name
</code></pre></div></div>
<p>Now we have a fully working container which we can use to develop our blog. We can now follow exactly the instructions from the jekyll website in order to create a sample blog: <code class="language-plaintext highlighter-rouge">jekyll new .</code> (don’t omit the dot!), <code class="language-plaintext highlighter-rouge">bundle exec jekyll serve --host 0.0.0.0 --port 8080</code>.</p>

<p><em>If you get an error (seg fault) there is a workaround <a href="https://github.com/protocolbuffers/protobuf/issues/16853">here</a>.</em></p>

<p>You can see what you made by opening the local address <a href="http://0.0.0.0:8080">http://0.0.0.0:8080</a>.</p>]]></content><author><name>Nasos Voutouras</name><email>nasosvt@gmail.com</email></author><category term="webdev," /><category term="docker," /><category term="tech" /><summary type="html"><![CDATA[Building a blog with Jekyll and Docker An easy guide and reference (mainly for myself). Probably not following best practices but it works. After reading the guide we’ll have a functional blog built by Jekyll, run locally in a container using Docker. Setting up the environment I am using Ubuntu. Get the Docker cli from the store or use sudo snap install docker to do it through the terminal. Visual Studio Code is an excellent editor that also has terminal. sudo snap install code --classic We might also need git and curl: sudo apt install git curl Now, we need to create our working directory. I already have my blog created so I git clone it. If you don’t have that, the only thing we need is an empty directory inside of which we are going to create the Dockerfile. The Dockerfile contains instructions on how the image is built, i.e. how the initial state of our container will look. We can create many containers using the same image. So, without further ado, we are going to create a new text file called Dockerfile and write the following text in it: FROM ruby:3.4.2-alpine3.21 RUN apk update RUN apk add --no-cache build-base gcc cmake git RUN gem update bundler &amp;&amp; gem install bundler jekyll This will instruct docker to create an alpine image (a minimal linux distribution) that includes ruby, update its packages, install some development tools and also install the bundler and jekyll gems (ruby packages). Now we need to create the image: docker build -t yourname/ruby . This command will download the required files so it can create an image of the OS using the instructions provided inside the Dockerfile. Now we need to create a container, mount our working directory to it, expose some ports and get a bash shell so we can run commands inside the container. We will use the docker run command along with some flags and arguments: docker run -it -v /path_to_working_dir/:/home/dev/blog -w /home/dev/blog --publish 8080:8080 your_image_name sh The flags -i, -t or -it give us the option to have an interactive session with a terminal. The -v flag is used to mount a directory from the host system (for me it’s the location of the cloned repository. All my files will then be shown in the container) for which we specify the directory we need to work in and its location inside the container. -w will mark the working directory so we get faster access to it. Finally, we expose some ports and also get a terminal wish sh. After running this command, we can get into the container by docker start -ai container_name Now we have a fully working container which we can use to develop our blog. We can now follow exactly the instructions from the jekyll website in order to create a sample blog: jekyll new . (don’t omit the dot!), bundle exec jekyll serve --host 0.0.0.0 --port 8080. If you get an error (seg fault) there is a workaround here. You can see what you made by opening the local address http://0.0.0.0:8080.]]></summary></entry><entry><title type="html">About my studies (or what I was doing in Sweden)</title><link href="http://0.0.0.0:8080/What-am-I-doing/" rel="alternate" type="text/html" title="About my studies (or what I was doing in Sweden)" /><published>2022-08-22T00:00:00+00:00</published><updated>2022-08-22T00:00:00+00:00</updated><id>http://0.0.0.0:8080/What%20am%20I%20doing</id><content type="html" xml:base="http://0.0.0.0:8080/What-am-I-doing/"><![CDATA[<p>This post is inspired by the awkward real-life encounters with people asking me what I am doing in my life. Since I am never satisfied with my answers, I’m gonna try to explain in text form…</p>

<h1 id="the-short-answer">The short answer</h1>
<p>First things first: I studied physics! Physics is the science that studies nature. My MSc programme focused on the theoretical aspect of high-energy and fundamental physics. That is quantum field theories from a more mathematical perspective; we studied the way small things interact with each other and how we can employ sophisticated mathematical tools to explain how the 4 fundamental forces work. The department has a strong presence in that particular field, especially in the scattering amplitudes domain which is what I am currently focused on with my thesis. If you’d like to check these subjects out, you can search for <a href="https://en.wikipedia.org/wiki/Quantum_field_theory">QFT</a> (main theoretical framework), <a href="https://en.wikipedia.org/wiki/Quantum_electrodynamics">QED</a>, <a href="https://en.wikipedia.org/wiki/Quantum_chromodynamics">QCD</a> and <a href="https://en.wikipedia.org/wiki/String_theory">String Theory</a> but beware of the maths!</p>

<p>Another domain I am very interested in is <a href="https://en.wikipedia.org/wiki/Quantum_computing">Quantum Information and Quantum Computing &amp; Algorithms</a>. In this field, we exploit the extraordinary properties of quantum particles to create powerful computational systems that can perform specific computations much faster than their classical counterparts.</p>

<h1 id="in-more-detail">In more detail…</h1>
<p>A theoretical physicist builds models (either empirically or mathematically) that aim to explain certain phenomena and make predictions.</p>

<p>In my area of interest <em>a theory</em> usually refers to the mathematical properties of the framework which can actually be incorporated into the Lagrangian (when dealing with fields we make use of the <em>Lagrangian density</em>) of the system. The Lagrangian is a function that basically encodes almost all the information of the physical properties of the system we are studying in a single expression. In more advanced and sophisticated theories, we will also need a few extras to build our models and get meaningful results.</p>

<p>Now, how can one quantity, \(L(q,p,t)\)- the Lagrangian, hold all the available information of the system? The truth is that in order to fully use \(L\), we need to build the <em>action</em>, \(S\), a <a href="https://en.wikipedia.org/wiki/Functional_(mathematics)">functional</a> that takes the Lagrangian and sums it over the time period of the phenomenon. Then, we use the <a href="https://en.wikipedia.org/wiki/Stationary-action_principle">Principle of Least Action</a> which helps us produce equations that upon solving, we can obtain a complete picture of the phenomenon.</p>

<p>Take <a href="https://en.wikipedia.org/wiki/N_%3D_4_supersymmetric_Yang%E2%80%93Mills_theory">\(N=4\) super(symmetric) Yang-Mills</a> for example. This is a supersymmetric theory, with 4 generators and a Yang-Mills potential term. The term “supersymmetric theory” refers to a Lagrangian which has an intrinsic property that allows for the exchange “Fermion \(\leftrightarrow\) Boson” without changing in a meaningful way (i.e. it has a <strong>symmetry</strong>). \(N=4\) refers to the number of supersymmetry generators, i.e. the number of operators whose action on a state performs a supersymmetry transformation. Another set of rules in the form of commutation/anti-commutation relations is needed in order to have a complete picture of the theory. This is the supersymmetric algebra. Of course, supersymmetry is not yet observed. Nevertheless, it’s a great example of highlighting the tools that go beyond the standard Lagrangian (generators, supersymmetric algebra, etc.). The <em>Standard Model</em> of particle physics, one of the most successful models/theories/frameworks the physics community has built works in a similar fashion (and gives actual results that can be observed in an accelerator).</p>

<p>The ultimate goal of a theory like that is to produce results that can be tested against experiments. Using the above (and spending an enormous amount of time calculating) we can produce expressions that correspond to real-life results in the form of <em>scattering amplitudes</em>. These mathematical expressions are written in terms of quantities that can be measured in an experimental setting. To derive such expressions, we make use of the Feynman diagrams and rules, a scheme that translates the huge mathematical expressions derived from Lagrangian formalism into simple diagrams. Each part of such diagram corresponds to a mathematical expression which is used, along with the rest of the diagram, to build the amplitude. Depending on the theory (Lagrangian) the rules that map the diagram to the expressions are modified accordingly.</p>

<h1 id="my-thesis">My thesis</h1>
<p>My thesis is focused on the <a href="https://arxiv.org/abs/2202.08257">5-dimensional spinor-helicity formalism</a>. The spinor-helicity formalism is a very compact way of expressing states of particles in quantum field theory. This comes in handy whenever the on-shell amplitudes are complicated (they usually are). Apparently, we can do some modifications to our momenta that would allow us to build up even more complicated amplitudes from simpler ones. For now, we are exploring these shifts and how they can work in the 5-D setting. Using that result, we can then implement this technique to construct more complicated amplitudes.</p>]]></content><author><name>Nasos Voutouras</name><email>nasosvt@gmail.com</email></author><category term="physics," /><category term="mathematics" /><summary type="html"><![CDATA[This post is inspired by the awkward real-life encounters with people asking me what I am doing in my life. Since I am never satisfied with my answers, I’m gonna try to explain in text form… The short answer First things first: I studied physics! Physics is the science that studies nature. My MSc programme focused on the theoretical aspect of high-energy and fundamental physics. That is quantum field theories from a more mathematical perspective; we studied the way small things interact with each other and how we can employ sophisticated mathematical tools to explain how the 4 fundamental forces work. The department has a strong presence in that particular field, especially in the scattering amplitudes domain which is what I am currently focused on with my thesis. If you’d like to check these subjects out, you can search for QFT (main theoretical framework), QED, QCD and String Theory but beware of the maths! Another domain I am very interested in is Quantum Information and Quantum Computing &amp; Algorithms. In this field, we exploit the extraordinary properties of quantum particles to create powerful computational systems that can perform specific computations much faster than their classical counterparts. In more detail… A theoretical physicist builds models (either empirically or mathematically) that aim to explain certain phenomena and make predictions. In my area of interest a theory usually refers to the mathematical properties of the framework which can actually be incorporated into the Lagrangian (when dealing with fields we make use of the Lagrangian density) of the system. The Lagrangian is a function that basically encodes almost all the information of the physical properties of the system we are studying in a single expression. In more advanced and sophisticated theories, we will also need a few extras to build our models and get meaningful results. Now, how can one quantity, \(L(q,p,t)\)- the Lagrangian, hold all the available information of the system? The truth is that in order to fully use \(L\), we need to build the action, \(S\), a functional that takes the Lagrangian and sums it over the time period of the phenomenon. Then, we use the Principle of Least Action which helps us produce equations that upon solving, we can obtain a complete picture of the phenomenon. Take \(N=4\) super(symmetric) Yang-Mills for example. This is a supersymmetric theory, with 4 generators and a Yang-Mills potential term. The term “supersymmetric theory” refers to a Lagrangian which has an intrinsic property that allows for the exchange “Fermion \(\leftrightarrow\) Boson” without changing in a meaningful way (i.e. it has a symmetry). \(N=4\) refers to the number of supersymmetry generators, i.e. the number of operators whose action on a state performs a supersymmetry transformation. Another set of rules in the form of commutation/anti-commutation relations is needed in order to have a complete picture of the theory. This is the supersymmetric algebra. Of course, supersymmetry is not yet observed. Nevertheless, it’s a great example of highlighting the tools that go beyond the standard Lagrangian (generators, supersymmetric algebra, etc.). The Standard Model of particle physics, one of the most successful models/theories/frameworks the physics community has built works in a similar fashion (and gives actual results that can be observed in an accelerator). The ultimate goal of a theory like that is to produce results that can be tested against experiments. Using the above (and spending an enormous amount of time calculating) we can produce expressions that correspond to real-life results in the form of scattering amplitudes. These mathematical expressions are written in terms of quantities that can be measured in an experimental setting. To derive such expressions, we make use of the Feynman diagrams and rules, a scheme that translates the huge mathematical expressions derived from Lagrangian formalism into simple diagrams. Each part of such diagram corresponds to a mathematical expression which is used, along with the rest of the diagram, to build the amplitude. Depending on the theory (Lagrangian) the rules that map the diagram to the expressions are modified accordingly. My thesis My thesis is focused on the 5-dimensional spinor-helicity formalism. The spinor-helicity formalism is a very compact way of expressing states of particles in quantum field theory. This comes in handy whenever the on-shell amplitudes are complicated (they usually are). Apparently, we can do some modifications to our momenta that would allow us to build up even more complicated amplitudes from simpler ones. For now, we are exploring these shifts and how they can work in the 5-D setting. Using that result, we can then implement this technique to construct more complicated amplitudes.]]></summary></entry></feed>